The Linux command line for beginners
https://tutorials.ubuntu.com/tutorial/command-line-for-beginners
Ubuntu Server 18.04 Essentials
https://www.youtube.com/playlist?list=PLT98CRl2KxKEKvszPW-d4wYLo2fxEJYKe

Ctrl+Alt+F3 - переход в текстовый интерфейс. Можно переключаться между терминалами, проставляя третьей кнопкой F4, F5, F6...
Вернуться обратно в GUI: Ctrl+Alt+F1
Ctrl+С - остановить процесс
Ctrl+Z - перевести процесс в фоновый режим
fg - перевести на foregrond (лицевую сторону) фоновый процесс
ps - показать текущие процессы
clear - очистить экран
sudo - сделать что-то с правами суперюзера (надо будет ввести пароль)
echo - напечатать что-то на экране или в файл, если после указать ">" и имя файла.
|  - разделитель комманд, сначала будет выполнена левая, потом правая. Выход левой комманды будет входом для правой.

man -k <интересующая команда keyword или её кусок>  - получить мануал (инструкцию) по команде
whatis <интересующая команда или её кусок>  - почти то же самое.
whereis <имя файла/папки> 		- показать директорию файла/папки

xrandr			- вывести поддерживаемые разрешения экрана
xrandr -s 1024x768      - установить разрешение экрана

НАВИГАЦИЯ И ПОИСК.
cd 	- перейти в папку
. - текущая директория
cd .. 	- перейти в папку выше
cd ../..  	- перейти на 2 папки выше
cd ~  	- перейти в папку home текущего пользователя, то же самое, что cd home
pwd 	- показать путь текущей папки
ls 	- показать сожержимое текущей папки
ls -la 		- показать сожержимое текущей папки, l - длинно, a - включая скрытые папки и файлы
sudo ls -la -R / 	- показать сожержимое корневой папки. Бежать данные по экрану будут очень долго )))
locate <имя файла/папки> 		- показать директорию файла/папки
find /home -name "<имя файла/папки>" 		- найти файл/папку, атрибут -name указывает, что ищем по имени
-i   		- атрибут игнорирования keysensitive - различия больших и маленьких букв


РАБОТА С ФАЙЛАМИ И ПАПКАМИ.
mkdir 		- создать папку
mkdir -p Dir4/Dir5  		- с атрибутом parent создает сразу родительскую и дочернюю папки
touch 		- создать файл, либо обновить время последней активности у существующего файла
rm 		- удалить файл
rmdir 		- удалить папку пустую
rmdir -p dir1/dir2/dir3  - удалить указанное дерево
-i 	- (interactive) option to rm, which will prompt you to confirm the deletion of each file; 

rm -R 		- удалить папку рекурсивно со всем её содержимым. ОПАСНО!  Лучше удалять содержимое вручную, потом .. и удалять папку обычным rmdir
sudo rm -R / 	- удалить всё с машины, начиная с корня, включая саму систему Linux


cat 	- ПРОСМОТРЕТЬ ФАЙЛ
more 	- тоже просмотреть файл, но по кнопке Enter читается по строкам. q - для выхода
less 	- тоже просмотреть файл, но работают ещё PgDown и PgUp, по кнопке / работает поиск. q - для выхода
cp <название файла> <путь, куда копируем>  - скопировать файл/папку
cp hello*.*  	- скопировать ВСЕ файлы с "hello" в начале названия, любым продолжением названия, с любым расширением
cp hello?.*  	- скопировать ВСЕ файлы с "hello" в начале названия и с любым 1 символом после этого.
cp -R Dir2 Dir 4 	- скопировать папку Dir2 со всем сожержимым в папку Dir4
-v 	- атрибут verbose, который на экране покажет процесс выполнения команды, например копирования файлов.
mv 	- переместить файл ИЛИ переименовать, если остваить файл в той же директории (mv text.txt rename.txt)
mv 	- сделать файл скрытым, если поставить точку в начале имени (mv text.txt .text.txt)


ПАМЯТЬ И ПРОЦЕССЫ
top  				- Task Manager, диспетчер задач в Linux, можем видеть процессы, память используемую и т.д.
Shift+P - отфильтровать по CPU, Shift+M 		- отфильтровать по памяти.
free -h 			- показать наличие памяти
ps				- показать текущие процессы на пользователе
ps x				- более подробное описание процессов
ps <имя пользователя>		- показать процессы другого пользователя
ps -aux				- подробные данные по процессам юзеров 
ps -aux | grep denis		- все процессы пользователя Денис
bg 				— переводит задание в фоновый режим работы
fg 				— переводит задание в режим работы на переднем плане.
kill 				— посылает сигнал процессу.
killall	<имя процесса> 			— терминирует ВСЕ процессы по указанному имени.
kill -STOP <имя процесса> 		- приостанавливает процесс
kill -CONT <имя процесса> 		- возобновляет процесс
shutdown 			— останавливает или перезагружает систему
/var/log				- место хранения логов
dmesg					- лог Линуксовского ядра, хранится в памяти, пока комп работает


ЗАПИСЬ В ФАЙЛЫ
gedit 			- открытие простого блокнота в GUI
nano 			- текстовый редактор прямо в терминале
pico			- она же, но версия постарше
vi			- древний редактор, он же vim, не дай Бог с ним работать. Имеет 2 режима и НЕ говорит, в каком он сейчас.


ЯРЛЫКИ, СОРТИНГ, РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
ln -s  		- создать ярлык на файл/папку
ln 		- создать ссылку-клон (как в Python вторая переменная, указывающая на тот же объект в памяти),
менять можно любой из них - второй изменится тоже

wc <имя файла> 		- (word count) выдаёт информацию о файле: количество строк, слов, символов (байтов)
атрибуты: -w - выдать кол-во слов, -l - строк.

sort <имя файла с данными> - возвращает данные в файле, сортированные по алфавиту 
-n    				- атрибут для сортировки чисел по возрастанию

cut -d "<символ-резделитель>" -f 3 <имя файла, в который это записать>  - разрезает строку по делиметеру -d, как split в Python, выдает массив кусочков. 
атрибут -f 3 		- (field) выбирает не весь массив, а только указанный элемент.

grep <искомый текст> <папка/файл> 		- ищет определённый текст в файлах/папках
МОЖНО ИСПОЛЬЗОВАТЬ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ.
grep -E "[A-Za-z].gov" mydatafile.txt		- ищем все вхождения с любой 1 буквой в любом регистре перед  ".gov"
grep -E "[A-Za-z]*.gov" mydatafile.txt		- ищем все вхождения с любым количеством букв перед  ".gov"
grep -E "(kgb.gov|intel.com)"  			- ищем (или то, или другое) через разделитель |


ПЕРЕНАПРАВЛЕНИЕ ВЫВОДА/ВВОДА
read				- прочитать вводимую строку
read <имя переменной>		- прочитать строку и присвоить её как значение переменной
sort names.txt     		- выведет отсортированное содержимое на экран
sort names.txt > sorted.txt  	-  выведет отсортированное содержимое в файл sorted.txt (если такой файл что-то содержал, сначала он затрётся!) 
Выдаёт только хорошие результаты, за исключением ошибок!
>>   				- append, добваить данные в конец файла, аналогично комманде append в Python
2> 		- перенаправить данные, выдавшие ошибки в...  вникуда в данном случае.
2> errors.txt	- перенаправить плохие ответы в файл errors.txt
grep anton /etc/* 2> /dev/null			- перенаправить плохие ответы в девайс "вникуда"
grep anton /etc/* > good.txt 2> errors.txt  	- разделили по 2 файлам хорошие ответы и плохие.
grep anton /etc/* &> allresults.txt		- вывести ВСЕ результаты, и плохие, и хорошие, в файл


АРХИВИРОВАНИЕ И КОМПРЕССИЯ ДАННЫХ
tar 			- tape archive - объединяет несколько файлов/папок в один
tar cvf mytar.tar Folder1	- запихнуть в файл mytar.tar всё содержимой папки Folder1, буква f должна быть последним атрибутом перед именем файла
tar tf mytar.tar		- посмотреть внутрь файла
tar xvf mytar.tar		- распаковать, показывая действия (v)

gzip mytar.tar 			- скомпрессировать 1 файл!  Файл получает новое расширение .gz и уменьшеается в размере. Получаем архив. Исходный большой файл исчезает.
gunzip mytar.tar.gz 		- раскомпрессировать файл.
bzip2 mytar.tar 		- скомпрессировать более мощным методом в формат .bz2
bunzip2 mytar.tar.bz2		- раскопрессировать
xz     и  unxz  		- скомпрессовать и раскомпрессовать в формат .xz 
tar cvzf mytar.tar Folder1	- закинуть в 1 файл и СРАЗУ скопрессировать. z - по методу gzip,   j - по методу bzip2, J - по методу xz.

zip -r myZIP.zip Folder1	- закинуть рекурсивно папку и всё её содержимое в архив zip? который откроется и на Windows легко (степень сжатия самая слабая)
unzip myZIP.zip			- распаковать zip-файл




ПОЛЬЗОВАТЕЛИ
cat /etc/passwd		- открыть файл с данными всех аккаунтов пользователей
whoami 			- показывает, какой юзер сейчас активен
su <имя юзера>		- switch user, меняет текущего юзера на указанного, попросит ввести пароль
exit			- выйти из временно примеренного юзера ))
id <имя юзера>		- показывает группы пользователя
last			- показывает крайние логины в систему
who			- показывает, кто сейчас залогинен в систему
w			- всё то же самое, но ещё показывает и текущий работающий процесс
sudo useradd -m <имя пользователя> 	- создаем нового юзера. -m создает ему папку в /home
sudo passwd <имя пользователя>		- установить пароль пользователю, чтобы он мог залогиниться
/etc/skel/		- папка-скелет, которая сожержит всё, что будет создаваться для нового пользователя
sudo userdel -r <имя пользователя>			- удалить пользователя и все его данные
sudo groupadd <имя группы>		- создать группу с указанным именем 
sudo groupdel <имя группы>		- удалить группу (пользователи сохраняются, просто выходят из этой группы)
sudo usermod -aG <имя группы> <имя пользователя> 		- добавить в группу пользователя
sudo deluser <имя группы> <имя пользователя>			- удалить из группы пользователя
logout				- выйти из текущего пользователя (root, например)


ПРАВА
rwx				- права на чтение, запись, исполнение файла (или вход в папку)
r--				- право только на чтение
sudo chown <имя пользователя> <имя файла/папки>		- поменять владельца файла/папки
sudo chgrp <имя группы> <имя файла/папки>		- поменять доступ группы
sudo chmod o+x <имя файла/папки>			- добавить право others (o) на запуск файла (x)
sudo chmod u+x, g-w, o+r <имя файла/папки>	- у юзера доавляем право запускать, у группы убираем право писать, у остальных добавляем право читать
chmod ugo=r <имя файла/папки>			- юзеру, группе и остальным - всем поставить толкьо право read, остальные права отключить
r = 4, w = 2, x = 1
rwx = 7, rw- = 6, r-x = 5, r-- = 4, -wx = 3, -w- = 2, --x = 1, --- = 0
chmod 777 <имя файла/папки>	- дать полные права всем. Первая 7 - пользователю, вторая - группе, третья - остальным.
sudo chmod o+t <имя папки>	 - сделать sticky beat для папки, запретить удалять файлы не владельцам файла.
sudo chmod 1777 <имя папки>		- сделать в папке полные права. Первая цифра - sticky beat. 1 включает, 0 выключает.

ifconfig			- данные о сети
ip addr show			- другой вариант данных о сети
route				- адреса пересылки пакетов в разных странах
ping				- отослать пакеты на адрес, проверить ответ (пропинговать)




УСТАНОВКА ДОПОЛНЕНИЙ НА VBOX для открытия общих папок
В VB настраиваем общие папки и затем проводим следующий команды:
http://the-komp.ru/virtualbox-dopolneniya-gostevoj-os.html
https://qna.habr.com/q/466840
cd /media/cdrom    - или немного по-другому - перейти в сд-ром, перед уэтим через меню Vbox монтирвоав сд-ром с дополнениями
sudo sh ./VBoxLinuxAdditions.run
sudo adduser username vboxsf
sudo reboot


BASH SCRIPTS
Формат файлов .sh
Начинается всегда с
#!/bin/bash
а ниже обычные команды линукса, разделённые Enter или ;
файлу скрипта надо дать возможность запускаться: chmod a+x myscript.sh
./myscript.sh				-  запустить скрипт с именем  myscript.sh, если мы в его директории
переменные пишутся в кавычках и со знаком $, затем пишется порядковый номер переменной. 
$0 - название файла со скриптом, $1 - первая переменная и т.д.
if [ "$1" == "Vasya" ]; then
	echo "Privet $1"
elif [ "$1" == "Trump" ]; then
	echo "Hello $1"
else echo "Zdarova, neznakomez, $1"
fi				- конец if, тот же if, но наоборот...

read -p "Please, enter something: " x
echo "Starting CASE selection..."
case $x in 
	1) echo "This is one";;
	[2-9]) echo "From two to nine";;
	"Petya") echo "Privet, $x";;
	*) echo "Parametr unknown"
esac				- конец case, тот же case, но наоборот...

COUNTER=0
while [ $COUNTER -lt 10 ]; do
	echo "Current counter is $COUNTER"
	COUNTER=$(($COUNTER+1))
	# let COUNTER+=1			- комментарий

for myfile in `ls *.txt`; do
	cat $myfile			- выведем содержание всех текстовых файлов
done

for x in {1...10}; do
	echo "X = $x"
done

for (( i=1; i<=10; i++ )); do
	echo "Nomer I = $i"
done


summa=0				- задаем переменную, в которую функция будет выдавать рещультат.
т.к. функция в bash не может возвращать рещультат просто так
myFunction()			- задаём функцию
{
	echo "This is a text from Function!"
	echo "First parametr is $1"
	echo "Second parametr is $2"
	summa=$(($1+$2))
}

myFunction 50 vasya			- вызываем функцию
"Summa = $summa"			- выводим изменившуюся переменную